/* $RCSfile$
* $Author: egonw $
* $Date: 2005-11-10 16:52:44 +0100 (jeu., 10 nov. 2005) $
* $Revision: 4255 $
*
* Copyright (C) 2004-2005  The Jmol Development Team
*
* Contact: jmol-developers@lists.sf.net
*
*  This library is free software; you can redistribute it and/or
*  modify it under the terms of the GNU Lesser General Public
*  License as published by the Free Software Foundation; either
*  version 2.1 of the License, or (at your option) any later version.
*
*  This library is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*  Lesser General Public License for more details.
*
*  You should have received a copy of the GNU Lesser General Public
*  License along with this library; if not, write to the Free Software
*  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
*/
using System;
namespace org.jmol.adapter.smarter
{
	
	/// <summary> This reader is for current.xyz files generated by Folding@Home project
	/// (see http://folding.stanford.edu)
	/// 
	/// I have not found a precise description of the file format.
	/// I used source code from fpd from Dick Howell to analyze the file format.
	/// (see http://boston.quik.com/rph)
	/// </summary>
	
	class FoldingXyzReader:AtomSetCollectionReader
	{
		
		// Enable / Disable features of the reader
		private const bool useAutoBond = false;
		
		internal override AtomSetCollection readAtomSetCollection(System.IO.StreamReader reader)
		{
			
			atomSetCollection = new AtomSetCollection("Folding@Home");
			
			try
			{
				SupportClass.Tokenizer tokens = new SupportClass.Tokenizer(reader.ReadLine(), " \t");
				if (tokens.HasMoreTokens())
				{
					int modelAtomCount = System.Int32.Parse(tokens.NextToken());
					atomSetCollection.newAtomSet();
					if (tokens.HasMoreTokens())
					{
						atomSetCollection.setAtomSetName("Protein " + tokens.NextToken());
					}
					readAtoms(reader, modelAtomCount);
				}
			}
			catch (System.Exception ex)
			{
				//UPGRADE_TODO: The equivalent in .NET for method 'java.lang.Throwable.toString' may return a different value. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1043'"
				atomSetCollection.errorMessage = "Could not read file:" + ex;
			}
			return atomSetCollection;
		}
		
		/// <param name="reader">
		/// </param>
		/// <param name="modelAtomCount">
		/// </param>
		/// <throws>  Exception </throws>
		internal virtual void  readAtoms(System.IO.StreamReader reader, int modelAtomCount)
		{
			// Stores bond informations
			int[][] bonds = new int[modelAtomCount + 1][];
			for (int i = 0; i <= modelAtomCount; ++i)
			{
				bonds[i] = null;
			}
			
			for (int i = 0; i <= modelAtomCount; ++i)
			{
				System.String line = reader.ReadLine();
				if ((line != null) && (line.Length == 0))
				{
					line = reader.ReadLine();
				}
				if (line != null)
				{
					//System.out.println("Line: " + line);
					Atom atom = atomSetCollection.addNewAtom();
					parseInt(line);
					atom.atomName = parseToken(line, ichNextParse);
					if (atom.atomName != null)
					{
						int carCount = 1;
						if (atom.atomName.Length >= 2)
						{
							char c1 = atom.atomName[0];
							char c2 = atom.atomName[1];
							if (System.Char.IsUpper(c1) && System.Char.IsLower(c2) && Atom.isValidElementSymbol(c1, c2))
							{
								carCount = 2;
							}
							if ((c1 == 'C') && (c2 == 'L'))
							{
								carCount = 2;
							}
						}
						atom.elementSymbol = atom.atomName.Substring(0, (carCount) - (0));
					}
					atom.x = parseFloat(line, ichNextParse);
					atom.y = parseFloat(line, ichNextParse);
					atom.z = parseFloat(line, ichNextParse);
					
					// Memorise bond informations
					int bondCount = 0;
					bonds[i] = new int[5];
					int bondNum = System.Int32.MinValue;
					while ((bondNum = parseInt(line, ichNextParse)) > 0)
					{
						if (bondCount == bonds[i].Length)
						{
							bonds[i] = setLength(bonds[i], bondCount + 1);
						}
						bonds[i][bondCount++] = bondNum - 1;
					}
					if (bondCount < bonds[i].Length)
					{
						bonds[i] = setLength(bonds[i], bondCount);
					}
				}
			}
			
			// Bonds
			if (!useAutoBond)
			{
				
				// Decide if first bond is relevant
				int incorrectBonds = 0;
				for (int origin = 0; origin < bonds.Length; origin++)
				{
					if ((bonds[origin] != null) && (bonds[origin].Length > 0))
					{
						bool correct = false;
						int destination = bonds[origin][0];
						if ((destination >= 0) && (destination < bonds.Length) && (bonds[destination] != null))
						{
							for (int j = 0; j < bonds[destination].Length; j++)
							{
								if (bonds[destination][j] == origin)
								{
									correct = true;
								}
							}
						}
						if (!correct)
						{
							incorrectBonds++;
						}
					}
				}
				
				// Create bond
				int start = (incorrectBonds * 5) > bonds.Length?1:0;
				for (int origin = start; origin < bonds.Length; origin++)
				{
					if (bonds[origin] != null)
					{
						for (int i = 0; i < bonds[origin].Length; i++)
						{
							bool correct = false;
							int destination = bonds[origin][i];
							if ((destination >= 0) && (destination < bonds.Length) && (bonds[destination] != null))
							{
								for (int j = start; j < bonds[destination].Length; j++)
								{
									if (bonds[destination][j] == origin)
									{
										correct = true;
									}
								}
							}
							if (correct && (destination > origin))
							{
								atomSetCollection.addNewBond(origin, destination);
							}
						}
					}
				}
			}
		}
	}
}